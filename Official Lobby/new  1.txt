
doGameStarter()

{
	level.gameState = "starting";
	level.lastAlive = 0;
	level waittill("CREATED");
	level thread doStartTimer();
	wait 10;
	foreach(player in level.players)
	{
		player thread doSetup();
	}
	wait 50;
	level thread doZombieTimer();
	VisionSetNaked("icbm", 5);
}

doStartTimer()
{
	level.counter = 60;
	while(level.counter > 0)
	{
		level.TimerText destroy();
		level.TimerText = level createServerFontString( "objective", 1.5 );
		level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
		level.TimerText setText("^2Game Starting in: " + level.counter);
		setDvar("fx_draw", 1);
		wait 1;
		level.counter--;
	}
	level.TimerText setText("");
	foreach(player in level.players)
	{
		player thread doSetup();
	}
}

doMapVote()
{
	level.gamestate = "voting";
	notifyVoting = spawnstruct();
	notifyVoting.titleText = "Map Voting Time!";
	notifyVoting.notifyText = "Vote for what the next map should be";
	notifyVoting.notifyText2 = "Not Voting counts as same map";
	notifyVoting.glowColor = (0.0, 0.6, 0.3);
	current = getDvar("mapname");
	level.mapnumber1 = randomInt(level.mapvote.size);
	level.mapnumber2 = randomInt(level.mapvote.size);
	level.mapnumber3 = randomInt(level.mapvote.size);
	mapchoice1 = level.mapvote[level.mapnumber1];
	mapchoice2 = level.mapvote[level.mapnumber2];
	mapchoice3 = level.mapvote[level.mapnumber3];
	level.choice1votes = 0;
	level.choice2votes = 0;
	level.choice3votes = 0;
	level.keepmapvotes = 0;
	while(mapchoice1 == mapchoice2 || mapchoice2 == mapchoice3 || mapchoice3 == mapchoice1 || mapchoice1 == current || mapchoice2 == current || mapchoice3 == current)
	{
		if(mapchoice1 == mapchoice2){
			level.mapnumber1 = randomInt(level.mapvote.size);
			level.mapnumber2 = randomInt(level.mapvote.size);
			mapchoice1 = level.mapvote[level.mapnumber1];
			mapchoice2 = level.mapvote[level.mapnumber2];
		}
		if(mapchoice2 == mapchoice3){
			level.mapnumber2 = randomInt(level.mapvote.size);
			level.mapnumber3 = randomInt(level.mapvote.size);
			mapchoice2 = level.mapvote[level.mapnumber2];
			mapchoice3 = level.mapvote[level.mapnumber3];
		}
		if(mapchoice3 == mapchoice1){
			level.mapnumber1 = randomInt(level.mapvote.size);
			level.mapnumber3 = randomInt(level.mapvote.size);
			mapchoice1 = level.mapvote[level.mapnumber1];
			mapchoice3 = level.mapvote[level.mapnumber3];
		}
		if(mapchoice1 == current){
			level.mapnumber1 = randomInt(level.mapvote.size);
			mapchoice1 = level.mapvote[level.mapnumber1];
		}
		if(mapchoice2 == current){
			level.mapnumber2 = randomInt(level.mapvote.size);
			mapchoice2 = level.mapvote[level.mapnumber2];
		}
		if(mapchoice3 == current){
			level.mapnumber3 = randomInt(level.mapvote.size);
			mapchoice3 = level.mapvote[level.mapnumber3];
		}
	}
	wait 1;
	foreach(player in level.players)
	{
		player thread maps\mp\gametypes\_hud_message::resetNotify();
		player thread doSetup();
	}
	wait 4;
	VisionSetNaked("blacktest", 2);
	foreach(player in level.players)
	{
		player.menu = -1;
		player.mapvoted = 0;
		player.maxhealth = 99999;
		player.health = player.maxhealth;
		player.option1 setText("Press [{+actionslot 3}] to vote for - " + level.mapname[level.mapnumber1]);
		player.option2 setText("Press [{+actionslot 4}] to vote for - " + level.mapname[level.mapnumber2]);
		player.option3 setText("Press [{+actionslot 2}] to vote for - " + level.mapname[level.mapnumber3]);
		player freezeControls(true);
		player thread maps\mp\gametypes\_hud_message::notifyMessage(notifyVoting);
	}
	level thread CountVotes();
	level thread MapVoteTimer();
	wait 20;
	level notify("EndMapVote");
	VisionSetNaked(getDvar("mapname"), 2);
	foreach(player in level.players)
	{
		if(player.mapvoted == 0){
			level.keepmapvotes++;
		}
	}
	foreach(player in level.players)
	{
		player.option1 setText(level.mapname[level.mapnumber1] + " - " + level.choice1votes);
		player.option2 setText(level.mapname[level.mapnumber2] + " - " + level.choice2votes);
		player.option3 setText(level.mapname[level.mapnumber3] + " - " + level.choice3votes);
	}
	level.TimerText setText("Keep the same map - " + level.keepmapvotes);
	wait 5;
	level notify("MapVotingOver");
	if(level.choice1votes > level.choice2votes && level.choice1votes > level.choice3votes && level.choice1votes > level.keepmapvotes){
		level thread ChangeMapTimer(level.mapname[level.mapnumber1]);
		wait 5;
		Map(level.mapvote[level.mapnumber1], false);
	} else if(level.choice2votes > level.choice1votes && level.choice2votes > level.choice3votes && level.choice2votes > level.keepmapvotes){
		level thread ChangeMapTimer(level.mapname[level.mapnumber2]);
		wait 5;
		Map(level.mapvote[level.mapnumber2], false);
	} else if(level.choice3votes > level.choice2votes && level.choice3votes > level.choice1votes && level.choice3votes > level.keepmapvotes){
		level thread ChangeMapTimer(level.mapname[level.mapnumber3]);
		wait 5;
		Map(level.mapvote[level.mapnumber3], false);
	} else {
		wait 5;
		level thread doIntermission();
		foreach(player in level.players)
		{
			player.menu = 0;
			player freezeControls(false);
			player.maxhealth = 100;
			player.health = player.maxhealth;
		}
	}
}

CountVotes()
{
	level endon("EndMapVote");
	for(;;)
	{
		foreach(player in level.players)
		{
			player.menu = -1;
			player.option1 setText("Press [{+actionslot 3}] to vote for - " + level.mapname[level.mapnumber1]);
			player.option2 setText("Press [{+actionslot 4}] to vote for - " + level.mapname[level.mapnumber2]);
			player.option3 setText("Press [{+actionslot 2}] to vote for - " + level.mapname[level.mapnumber3]);
			if(player.mapvoted == 0){
				if(player.buttonPressed["+actionslot 3"] == 1){
					player.buttonPressed["+actionslot 3"] = 0;
					player.mapvoted = 1;
					level.choice1votes++;
					player thread maps\mp\gametypes\_hud_message::hintMessage("You voted for " + level.mapname[level.mapnumber1]);
				}
				if(player.buttonPressed["+actionslot 4"] == 1){
					player.buttonPressed["+actionslot 4"] = 0;
					player.mapvoted = 1;
					level.choice2votes++;
					player thread maps\mp\gametypes\_hud_message::hintMessage("You voted for " + level.mapname[level.mapnumber2]);
				}
				if(player.buttonPressed["+actionslot 2"] == 1){
					player.buttonPressed["+actionslot 2"] = 0;
					player.mapvoted = 1;
					level.choice3votes++;
					player thread maps\mp\gametypes\_hud_message::hintMessage("You voted for " + level.mapname[level.mapnumber3]);
				}
			}
		}
		wait .0001;
	}
}

MapVoteTimer()
{
	level endon("MapVotingOver");
	level.counter = 20;
	while(level.counter > 0)
	{
		level.TimerText destroy();
		level.TimerText = level createServerFontString( "objective", 1.5 );
		level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
		level.TimerText setText("^2Map Vote Ending in: " + level.counter);
		VisionSetNaked("blacktest", 0);
		wait 1;
		level.counter--;
	}
	level.TimerText setText("");
	while(1)
	{
		foreach(player in level.players)
		{
			player.menu = -1;
			player.option1 setText(level.mapname[level.mapnumber1] + " - " + level.choice1votes);
			player.option2 setText(level.mapname[level.mapnumber2] + " - " + level.choice2votes);
			player.option3 setText(level.mapname[level.mapnumber3] + " - " + level.choice3votes);
		}
		level.TimerText setText("Keep the same map - " + level.keepmapvotes);
		wait .25;
	}
}

ChangeMapTimer(nextmap)
{
	level.counter = 5;
	while(level.counter > 0)
	{
		level.TimerText destroy();
		level.TimerText = level createServerFontString( "objective", 1.5 );
		level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
		level.TimerText setText("^2Changing to " + nextmap + " in: " + level.counter);
		VisionSetNaked("blacktest", 0);
		wait 1;
		level.counter--;
	}
	level.TimerText setText("");
}

doIntermission()
{
	level.gameState = "intermission";
	level.lastAlive = 0;
	level thread doIntermissionTimer();
	level notify("RESETDOORS");
	level notify("RESETCLUSTER");
	setDvar("cg_drawCrosshair", 1);
	setDvar("cg_drawCrosshairNames", 1);
	setDvar("cg_drawFriendlyNames", 1);
	wait 5;
	foreach(player in level.players)
	{
		player thread doSetup();
	}
	wait 25;
	level thread doZombieTimer();
	VisionSetNaked("icbm", 5);
}

doIntermissionTimer()
{
	level.counter = 30;
	while(level.counter > 0)
	{
		level.TimerText destroy();
		level.TimerText = level createServerFontString( "objective", 1.5 );
		level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
		level.TimerText setText("^2Intermission: " + level.counter);
		setDvar("fx_draw", 1);
		wait 1;
		level.counter--;
	}
	level.TimerText setText("");
	foreach(player in level.players)
	{
		player thread doSetup();
	}
}

doZombieTimer()
{
	setDvar("cg_drawCrosshair", 1);
	level.counter = 30;
	while(level.counter > 0)
	{
		level.TimerText destroy();
		level.TimerText = level createServerFontString( "objective", 1.5 );
		level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
		level.TimerText setText("^1Alpha Zombie in: " + level.counter);
		wait 1;
		level.counter--;
	}
	level.TimerText setText("");
	level thread doPickZombie();
}

doPickZombie()
{
	level.Zombie1 = randomInt(level.players.size);
	level.Zombie2 = randomInt(level.players.size);
	level.Zombie3 = randomInt(level.players.size);
	level.Alpha = 2;
	if(level.players.size < 5){
		level.Alpha = 1;
	}
	if(level.players.size > 10){
		level.Alpha = 3;
	}
	if(level.Alpha == 1){
		level.players[level.Zombie1].isZombie = 2;
		level.players[level.Zombie1] thread doAlphaZombie();
	}
	if(level.Alpha == 2){
		while(level.Zombie1 == level.Zombie2){
			level.Zombie2 = randomInt(level.players.size);
		}
		level.players[level.Zombie1].isZombie = 2;
		level.players[level.Zombie1] thread doAlphaZombie();
		level.players[level.Zombie2].isZombie = 2;
		level.players[level.Zombie2] thread doAlphaZombie();
	}
	if(level.Alpha == 3){
		while(level.Zombie1 == level.Zombie2 || level.Zombie2 == level.Zombie3 || level.Zombie1 == level.Zombie3){
			level.Zombie2 = randomInt(level.players.size);
			level.Zombie3 = randomInt(level.players.size);
		}
		level.players[level.Zombie1].isZombie = 2;
		level.players[level.Zombie1] thread doAlphaZombie();
		level.players[level.Zombie2].isZombie = 2;
		level.players[level.Zombie2] thread doAlphaZombie();
		level.players[level.Zombie3].isZombie = 2;
		level.players[level.Zombie3] thread doAlphaZombie();
	}
	level playSoundToAll("mp_defeat");
	level.TimerText destroy();
	level.TimerText = level createServerFontString( "objective", 1.5 );
	level.TimerText setPoint( "CENTER", "CENTER", 0, -100 );
	level.timerText setText("^1Alpha Zombies RELEASED!");
	level.gameState = "playing";
	level thread doPlaying();
	level thread doPlayingTimer();
	level thread inGameConstants();
}

doPlaying()
{
	wait 5;
	level.TimerText destroy();
	while(1)
	{
		level.playersLeft = maps\mp\gametypes\_teams::CountPlayers();
		if(level.lastAlive == 0){
			if(level.playersLeft["allies"] == 1){
				level.lastAlive = 1;
				foreach(player in level.players){
					if(player.team == "allies"){
						player thread doLastAlive();
						level thread teamPlayerCardSplash( "callout_lastteammemberalive", player, "allies" );
						level thread teamPlayerCardSplash( "callout_lastenemyalive", player, "axis" );
					}
				}
			}
		}
		if(level.playersLeft["allies"] == 0 || level.playersLeft["axis"] == 0){
			level thread doEnding();
			return;
		}
		wait .5;
	}
}

doPlayingTimer()
{
	level.minutes = 0;
	level.seconds = 0;
	while(1)
	{
		wait 1;
		level.seconds++;
		if(level.seconds == 60){
			level.minutes++;
			level.seconds = 0;
		}
		if(level.gameState == "ending"){
			return;
		}
	}
}

doEnding()
{
	level.gameState = "ending";
	notifyEnding = spawnstruct();
	notifyEnding.titleText = "Round Over!";
	notifyEnding.notifyText2 = "Next Round Starting Soon!";
	notifyEnding.glowColor = (0.0, 0.6, 0.3);
	
	if(level.playersLeft["allies"] == 0){
		notifyEnding.notifyText = "Humans Survived: " + level.minutes + " minutes " + level.seconds + " seconds.";
	}
	if(level.playersLeft["axis"] == 0){
		notifyEnding.notifyText = "All the Zombies disappeared!";
	}
	wait 1;
	VisionSetNaked("blacktest", 2);
	foreach(player in level.players)
	{
		player thread maps\mp\gametypes\_hud_message::resetNotify();
		player _clearPerks();
		player freezeControls(true);
		player thread maps\mp\gametypes\_hud_message::notifyMessage( notifyEnding );
	}
	wait 3;
	VisionSetNaked(getDvar( "mapname" ), 2);
	foreach(player in level.players)
	{
		player freezeControls(false);
	}
	level thread doMapVote();
}

Donate()
{
	self endon("disconncet");
	while(1)
	{
		self sayall("^2Please Donate to Kill" + "ingdyl!");
		wait 120;
	}
}

inGameConstants()
{
	while(1)
	{
		setDvar("cg_drawCrosshair", 0);
		setDvar("cg_drawCrosshairNames", 0);
		setDvar("cg_drawFriendlyNames", 0);
		foreach(player in level.players){
			player VisionSetNakedForPlayer("icbm", 0);
			player setClientDvar("lowAmmoWarningNoAmmoColor2", 0, 0, 0, 0);
			player setClientDvar("lowAmmoWarningNoAmmoColor1", 0, 0, 0, 0);
			player setClientDvar("cg_drawCrosshairNames", 0);
			player setClientDvar("cg_drawFriendlyNames", 0);
			player setClientDvar("fx_draw", 1);
		}
		wait 1;
		if(level.gameState == "ending"){
			return;
		}
	}
}

VoteKickCountYes()
{
	level endon("EndKickVote");
	for(;;)
	{
		foreach(player in level.players)
		{
			if(player.buttonPressed["+frag"] == 1){
				player.buttonPressed["+frag"] = 0;
				if(player.kickvoted == 0){
					player.kickvoted = 1;
					level.yesvote++;
					player iPrintlnBold("^2Vote Registered for ^3Yes");
				} else {
					player iPrintlnBold("^1Vote Already Registered");
				}
			}
		}
		wait .0001;
	}
}

VoteKickCountNo()
{
	level endon("EndKickVote");
	for(;;)
	{
		foreach(player in level.players)
		{
			if(player.buttonPressed["+frag"] == 1){
				player.buttonPressed["+frag"] = 0;
				if(player.kickvoted == 0){
					player.kickvoted = 1;
					level.novote++;
					player iPrintlnBold("^2Vote Registered for ^3No");
				} else {
					player iPrintlnBold("^1Vote Already Registered");
				}
			}
		}
		wait .0001;
	}
}

InitVoteKick(player, initiator)
{
	kicktimer = createServerFontString( "default", 1.5 );
	kicktimer setPoint( "CENTER", "TOP", 0, 20 );
	kicktext = createServerFontString( "default", 1.5 );
	kicktext setPoint( "CENTER", "TOP", 0, 40 );
	counter = 30;
	foreach(players in level.players)
	{
		players iPrintlnBold("A vote kick against: ^1" + player.name + " ^7has been initiated by ^2" + initiator.name + ": ^7Yes Vote Time" );
		players.kickvoted = 0;
		players.kickmenu = 0;
	}
	level.yesvote = 0;
	level.novote = 0;
	level thread VoteKickCountYes();
	while(counter > 15)
	{
		kicktimer setText("Vote kick ending in: " + counter);
		kicktext setText("Vote kick against: ^1" + player.name + " ^7by ^2" + initiator.name + "\n^7Press ^3[{+frag}] ^7to Vote ^4Yes");
		wait 1;
		counter--;
	}
	level notify("EndKickVote");
	foreach(players in level.players)
	{
		players iPrintlnBold("A vote kick against: ^1" + player.name + " ^7has been initiated by ^2" + initiator.name + ": ^7No Vote Time" );
	}
	level thread VoteKickCountNo();
	while(counter > 0)
	{
		kicktimer setText("Vote kick ending in: " + counter);
		kicktext setText("Vote kick against: ^1" + player.name + " ^7by ^2" + initiator.name + "\n^7Press ^3[{+frag}] ^7to Vote ^4No");
		wait 1;
		counter--;
	}
	level notify("EndKickVote");
	kicktimer setText("Vote kick against: " + player.name);
	kicktext setText("Yes - " + level.yesvote + "\nNo - " + level.novote);
	if(level.yesvote > level.novote){
		kick( player getEntityNumber() );
	}
	wait 5;
	kicktimer destroy();
	kicktext destroy();
	level.votekick = 0;
}

KickMenu()
{
	self endon("disconnect");
	disp = self createFontString( "default", 1.25 );
	disp setPoint( "CENTER", "CENTER", 0, 0 );
	self.kickmenu = 0;
	for(p = 0;;)
	{
		while(self.kickmenu == 1)
		{
			if(self.buttonPressed["+melee"] == 1){
				self.buttonPressed["+melee"] = 0;
				self.kickmenu = 0;
			}
			if(self.buttonPressed["+forward"] == 1){
				self.buttonPressed["+forward"] = 0;
				p += 1;
				if(p >= level.players.size){
					p = 0;
				}
			}
			if(self.buttonPressed["+back"] == 1){
				self.buttonPressed["+back"] = 0;
				p -= 1;
				if(p < 0){
					p = level.players.size - 1;
				}
			}
			c = p - 1;
			if(c < 0){
				c = level.players.size - 1;
			}
			d = p + 1;
			if(d >= level.players.size){
				d = 0;
			}
			disp setText(level.players[d].name + "\n^1" + level.players[p].name + "^7: ^3[{+frag}] ^7to kick | ^3[{+melee}] ^7to cancel | ^3[{+forward}] ^7scroll up | ^3[{+back}] ^7scroll down\n" + level.players[c].name);
			if(self.buttonPressed["+frag"] == 1){
				self.buttonPressed["+frag"] = 0;
				level thread InitVoteKick(level.players[p], self);
				level.votekick = 1;
				self.kickmenu = 0;
			}
			wait 0.05;
		}
		if(self.buttonPressed["+frag"] == 1){
			self.buttonPressed["+frag"] = 0;
			if(level.votekick == 0){
				self.kickmenu = 1;
			} else {
				self.kickmenu = 0;
			}
		}
		disp setText("");
		wait 0.05;
	}
}

doMenuScroll()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		if(self.buttonPressed[ "+smoke" ] == 1){
			self.buttonPressed[ "+smoke" ] = 0;
			self.menu--;
			if(self.menu < 0){
				if(self.team == "allies"){
					self.menu = level.humanM.size-1;
				} else {
					self.menu = level.zombieM.size-1;
				}
			}
		}
		if(self.buttonPressed[ "+actionslot 1" ] == 1){
			self.buttonPressed[ "+actionslot 1" ] = 0;
			self.menu++;
			if(self.team == "allies"){
				if(self.menu >= level.humanM.size){
					self.menu = 0;
				}
			} else {
				if(self.menu >= level.zombieM.size){
					self.menu = 0;
				}
			}
		}
		wait .045;
	}
}

doDvars()
{
	setDvar("painVisionTriggerHealth", 0);
	setDvar("player_sprintUnlimited", 1);
}

doHealth()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		self.curhealth = self.health;
		self.healthtext destroy();
		self.healthtext = NewClientHudElem( self );
		self.healthtext.alignX = "right";
		self.healthtext.alignY = "top";
		self.healthtext.horzAlign = "right";
		self.healthtext.vertAlign = "top";
		self.healthtext.y = -25;
		self.healthtext.foreground = true;
		self.healthtext.fontScale = 1;
		self.healthtext.font = "hudbig";
		self.healthtext.alpha = 1;
		self.healthtext.glow = 1;
		self.healthtext.glowColor = ( 2.55, 0, 0 );
		self.healthtext.glowAlpha = 1;
		self.healthtext.color = ( 1.0, 1.0, 1.0 );
		self.healthtext setText("Max Health: " + self.maxhealth);
		self waittill("health");
	}
}

doCash()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		self.cash destroy();
		self.cash = NewClientHudElem( self );
		self.cash.alignX = "right";
		self.cash.alignY = "top";
		self.cash.horzAlign = "right";
		self.cash.vertAlign = "top";
		self.cash.foreground = true;
		self.cash.fontScale = 1;
		self.cash.font = "hudbig";
		self.cash.alpha = 1;
		self.cash.glow = 1;
		self.cash.glowColor = ( 0, 1, 0 );
		self.cash.glowAlpha = 1;
		self.cash.color = ( 1.0, 1.0, 1.0 );
		self.cash setText("Cash: " + self.bounty);
		self waittill("CASH");
	}
}

doHUDControl()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		self.HintText setText(self.hint);
		self.hint = "";
		if(self.team == "allies"){
			switch(self.perkz["steadyaim"])
			{
				case 2:
					self.perkztext1 setText("Steady Aim: Pro");
					self.perkztext1.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext1 setText("Steady Aim: Activated");
					self.perkztext1.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext1 setText("Steady Aim: Not Activated");
					self.perkztext1.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["sleightofhand"])
			{
				case 2:
					self.perkztext2 setText("Sleight of Hand: Pro");
					self.perkztext2.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext2 setText("Sleight of Hand: Activated");
					self.perkztext2.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext2 setText("Sleight of Hand: Not Activated");
					self.perkztext2.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["sitrep"])
			{
				case 2:
					self.perkztext3 setText("SitRep: Pro");
					self.perkztext3.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext3 setText("SitRep: Activated");
					self.perkztext3.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext3 setText("SitRep: Not Activated");
					self.perkztext3.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["stoppingpower"])
			{
				case 2:
					self.perkztext4 setText("Stopping Power: Pro");
					self.perkztext4.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext4 setText("Stopping Power: Activated");
					self.perkztext4.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext4 setText("Stopping Power: Not Activated");
					self.perkztext4.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["coldblooded"])
			{
				case 2:
					self.perkztext5 setText("Cold Blooded: Pro");
					self.perkztext5.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext5 setText("Cold Blooded: Activated");
					self.perkztext5.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext5 setText("Cold Blooded: Not Activated");
					self.perkztext5.glowColor = ( 1, 0, 0 );
					break;
			}
			if((self.menu == 1) || (self.menu == 2)){
				current = self getCurrentWeapon();
				if(self.menu == 1){
					if(self.attach["akimbo"] == 1){
						self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]);
					} else {
						self.option1 setText("Upgrade Unavailable");
					}
					if(self.attach["fmj"] == 1){
						self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]);
					} else {
						self.option2 setText("Upgrade Unavailable");
					}
					if(self.attach["eotech"] == 1){
						self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]);
					} else {
						self.option3 setText("Upgrade Unavailable");
					}
				}
				if(self.menu == 2){
					if(self.attach["silencer"] == 1){
						self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]);
					} else {
						self.option1 setText("Upgrade Unavailable");
					}
					if(self.attach["xmags"] == 1){
						self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]);
					} else {
						self.option2 setText("Upgrade Unavailable");
					}
					if(self.attach["rof"] == 1){
						self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]);
					} else {
						self.option3 setText("Upgrade Unavailable");
					}
				}
			} else if(self.menu == 3 || self.menu == 4){
				if(self.menu == 3){
					switch(self.perkz["steadyaim"])
					{
						case 0:
							self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]["normal"]);
							break;
						case 1:
							self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]["pro"]);
							break;
						case 2:
						default:
							self.option1 setText("Perk can not be upgraded");
							break;
					}
					switch(self.perkz["sleightofhand"])
					{
						case 0:
							self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]["normal"]);
							break;
						case 1:
							self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]["pro"]);
							break;
						case 2:
						default:
							self.option2 setText("Perk can not be upgraded");
							break;
					}
					switch(self.perkz["sitrep"])
					{
						case 0:
							self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]["normal"]);
							break;
						case 1:
							self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]["pro"]);
							break;
						case 2:
						default:
							self.option3 setText("Perk can not be upgraded");
							break;
					}
				}
				if(self.menu == 4){
					switch(self.perkz["stoppingpower"])
					{
						case 0:
							self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]["normal"]);
							break;
						case 1:
							self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]["pro"]);
							break;
						case 2:
						default:
							self.option1 setText("Perk can not be upgraded");
							break;
					}
					switch(self.perkz["coldblooded"])
					{
						case 0:
							self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]["normal"]);
							break;
						case 1:
							self.option2 setText("Press [{+actionslot 4}] - " + level.humanM[self.menu][1]["pro"]);
							break;
						case 2:
						default:
							self.option2 setText("Perk can not be upgraded");
							break;
					}
					self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]);
				}
			}
			if(self.menu == 0){
				self.option1 setText("Press [{+actionslot 3}] - " + level.humanM[self.menu][0]);
				self.option2 setText(level.humanM[self.menu][1][self.exTo]);
				self.option3 setText("Press [{+actionslot 2}] - " + level.humanM[self.menu][2]);
			}
		}
		if(self.team == "axis"){
			switch(self.perkz["coldblooded"])
			{
				case 2:
					self.perkztext1 setText("Cold Blooded: Pro");
					self.perkztext1.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext1 setText("Cold Blooded: Activated");
					self.perkztext1.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext1 setText("Cold Blooded: Not Activated");
					self.perkztext1.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["ninja"])
			{
				case 2:
					self.perkztext2 setText("Ninja: Pro");
					self.perkztext2.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext2 setText("Ninja: Activated");
					self.perkztext2.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext2 setText("Ninja: Not Activated");
					self.perkztext2.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["lightweight"])
			{
				case 2:
					self.perkztext3 setText("Lightweight: Pro");
					self.perkztext3.glowColor = ( 0, 1, 0 );
					break;
				case 1:
					self.perkztext3 setText("Lightweight: Activated");
					self.perkztext3.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext3 setText("Lightweight: Not Activated");
					self.perkztext3.glowColor = ( 1, 0, 0 );
					break;
			}
			switch(self.perkz["finalstand"])
			{
				case 2:
					self.perkztext4 setText("Final Stand: Activated");
					self.perkztext4.glowColor = ( 0, 1, 0 );
					break;
				default:
					self.perkztext4 setText("Final Stand: Not Activated");
					self.perkztext4.glowColor = ( 1, 0, 0 );
					break;
			}
			self.perkztext5 setText("");
			if(self.menu == 1 || self.menu == 2){
				if(self.menu == 1){
					switch(self.perkz["coldblooded"])
					{
						case 0:
							self.option1 setText("Press [{+actionslot 3}] - " + level.zombieM[self.menu][0]["normal"]);
							break;
						case 1:
							self.option1 setText("Press [{+actionslot 3}] - " + level.zombieM[self.menu][0]["pro"]);
							break;
						case 2:
						default:
							self.option1 setText("Perk can not be upgraded");
							break;
					}
					switch(self.perkz["ninja"])
					{
						case 0:
							self.option2 setText("Press [{+actionslot 4}] - " + level.zombieM[self.menu][1]["normal"]);
							break;
						case 1:
							self.option2 setText("Press [{+actionslot 4}] - " + level.zombieM[self.menu][1]["pro"]);
							break;
						case 2:
						default:
							self.option2 setText("Perk can not be upgraded");
							break;
					}
					switch(self.perkz["lightweight"])
					{
						case 0:
							self.option3 setText("Press [{+actionslot 2}] - " + level.zombieM[self.menu][2]["normal"]);
							break;
						case 1:
							self.option3 setText("Press [{+actionslot 2}] - " + level.zombieM[self.menu][2]["pro"]);
							break;
						case 2:
						default:
							self.option3 setText("Perk can not be upgraded");
							break;
					}
				}
				if(self.menu == 2){
					switch(self.perkz["finalstand"])
					{
						case 0:
							self.option1 setText("Press [{+actionslot 3}] - " + level.zombieM[self.menu][0]["normal"]);
							break;
						case 1:
						case 2:
						default:
							self.option1 setText("Perk can not be upgraded");
							break;
					}
					self.option2 setText("");
					self.option3 setText("");
				}
			} else {
				self.option1 setText("Press [{+actionslot 3}] - " + level.zombieM[self.menu][0]);
				self.option2 setText("Press [{+actionslot 4}] - " + level.zombieM[self.menu][1]);
				self.option3 setText("Press [{+actionslot 2}] - " + level.zombieM[self.menu][2]);
			}
		}
		wait .5;
	}
}

doServerHUDControl()
{
	level.infotext setText("^1Welcome to Quarantine Chaos Zombie Mod! ^3Version 3.0! ^2Info: ^2[{+smoke}] ^3and ^2[{+actionslot 1}] ^3 scroll menu. ^2[{+frag}] ^3kick menu. ^1Zombies can ^2break down ^1doors!. ^2Created by Killingdyl. ^3Donate:^2Killingdyl@yahoo.com");
	//Edit infotext2 NOT infotext!!!!!!!!!!!!!!!!!!
	level.infotext2 setText("^7Join: ^3www.unleashedmods.com: ^7to offer me ideas. ^3Don't Forget to vote for a different map.");
	level.scrollright setText(">");
	level.scrollleft setText("<");
}

doInfoScroll()
{
	self endon("disconnect");
	for(i = 1600; i >= -3800; i -= 4)
	{
		level.infotext.x = i;
		level.infotext2.x = i + 2400;
		if(i == -3800){
			i = 3800;
		}
		wait .005;
	}
}

doScoreReset()
{
	self.pers["score"] = 0;
	self.pers["kills"] = 0;
	self.pers["assists"] = 0;
	self.pers["deaths"] = 0;
	self.pers["suicides"] = 0;
	self.score = 0;
	self.kills = 0;
	self.assists = 0;
	self.deaths = 0;
	self.suicides = 0;
}

doPerksSetup()
{
	self.perkz = [];
	self.perkz["steadyaim"] = 0;
	self.perkz["stoppingpower"] = 0;
	self.perkz["sitrep"] = 0;
	self.perkz["sleightofhand"] = 0;
	self.perkz["coldblooded"] = 0;
	self.perkz["ninja"] = 0;
	self.perkz["lightweight"] = 0;
	self.perkz["finalstand"] = 0;
}

doSpawn()
{
	if(level.gameState == "playing" || level.gameState == "ending"){
		if(self.deaths > 0 && self.isZombie == 0 && self.team == "allies"){
			self.isZombie = 1;
		}
		if(self.isZombie == 0){
			self thread doSetup();
		}
		if(self.isZombie == 1){
			self thread doZombie();
		}
		if(self.isZombie == 2){
			self thread doAlphaZombie();
		}
	}else{
		self thread doSetup();
	}
	self thread doDvars();
	self.menu = 0;
	self.attackeddoor = 0;
	self thread CreatePlayerHUD();
	self thread doMenuScroll();
	self thread doHUDControl();
	self thread doCash();
	self thread doHealth();
	self thread destroyOnDeath();
	self notify("health");
	self notify("cash");
	if(level.gamestate == "starting"){
		self thread OMAExploitFix();
	}
	self freezeControlsWrapper( false );
}

doJoinTeam()
{	
	if(self.CONNECT == 1){
		notifyHello = spawnstruct();
		notifyHello.titleText = "Welcome to the ^0Zombie Mod ^7server!";
		notifyHello.notifyText = "Please join ^1Chopper Gunner ^7 group on Steam!";
		notifyHello.notifyText2 = "Version 3.0 Mod Created By ^0Killing^1Dyl^7!";
		notifyHello.glowColor = (0.0, 0.6, 0.3);
		if(level.gamestate == "voting" || level.gameState == "intermission" || level.gameState == "starting"){
			self notify("menuresponse", game["menu_team"], "allies");
			self thread maps\mp\gametypes\_hud_message::notifyMessage( notifyHello );
		}
		if(level.gameState == "playing" || level.gameState == "ending"){
			self notify("menuresponse", game["menu_team"], "spectator");
			self allowSpectateTeam( "freelook", true );
			self thread maps\mp\gametypes\_hud_message::notifyMessage( notifyHello );
			self iPrintlnBold("^2 Please wait for round to be over.");
			self thread ReconnectPrevention();
		}
		self.CONNECT = 0;
	}
}

ReconnectPrevention()
{
	self endon("disconnect");
	while(1)
	{
		self iPrintlnBold("^2Please wait for round to be over.");
		if(self.team != "spectator"){
			self notify("menuresponse", game["menu_team"], "spectator");
		}
		maps\mp\gametypes\_spectating::setSpectatePermissions();
		self allowSpectateTeam( "freelook", true );
		self.sessionstate = "spectator";
		self setContents( 0 );
		if(level.gameState == "intermission"){
			return;
		}
		wait 1;
	}
}

doInit()
{
	level.gameState = "";
	level thread weaponInit();
	level thread CostInit();
	level thread MenuInit();
	level thread MapVoteInit();
	level thread CreateServerHUD();
	level thread doServerHUDControl();
	level thread OverRider();
	level thread RemoveTurrets();
	level thread maps\mp\killstreaks\_mapdata::init();
	setDvar("g_gametype", "war");
	setDvar("ui_gametype", "war");
	setDvar("scr_war_scorelimit", 0);
	setDvar("scr_war_timelimit", 0);
	setDvar("scr_war_waverespawndelay", 0);
	setDvar("scr_war_playerrespawndelay", 0);
	setDvar("camera_thirdperson", 0);
	wait 10;
	level thread doGameStarter();
	if(level.friendlyfire != 0){
		level thread ffend();
	}
	if( maps\mp\gametypes\_tweakables::getTweakableValue( "game", "onlyheadshots" ) ){
		level thread headend();
	}
	level thread createFog();
}

CostInit()
{
	level.itemCost = [];
	/** Human **/
	level.itemCost["ammo"] = 200;
	level.itemCost["LMG"] = 450;
	level.itemCost["Assault Rifle"] = 150;
	level.itemCost["Machine Pistol"] = 50;
	level.itemCost["Riot"] = 450;
	level.itemCost["Akimbo"] = 300;
	level.itemCost["Eotech"] = 50;
	level.itemCost["FMJ"] = 150;
	level.itemCost["Silencer"] = 300;
	level.itemCost["XMags"] = 150;
	level.itemCost["ROF"] = 50;
	level.itemCost["SentryGun"] = 750;
	/** Zombie **/
	level.itemCost["health"] = 50;
	level.itemCost["Thermal"] = 200;
	level.itemCost["ThrowingKnife"] = 400;
	/** Perks **/
	level.itemCost["SteadyAim"] = 150;
	level.itemCost["SteadyAimPro"] = 250;
	level.itemCost["SleightOfHand"] = 200;
	level.itemCost["SleightOfHandPro"] = 150;
	level.itemCost["SitRep"] = 100;
	level.itemCost["SitRepPro"] = 200;
	level.itemCost["StoppingPower"] = 400;
	level.itemCost["StoppingPowerPro"] = 50;
	level.itemCost["ColdBlooded"] = 250;
	level.itemCost["ColdBloodedPro"] = 100;
	level.itemCost["Ninja"] = 100;
	level.itemCost["NinjaPro"] = 250;
	level.itemCost["Lightweight"] = 150;
	level.itemCost["LightweightPro"] = 50;
	level.itemCost["FinalStand"] = 200;
}

weaponInit()
{
	level.lmg = [];
	level.lmg[0] = "rpd";
	level.lmg[1] = "sa80";
	level.lmg[2] = "mg4";
	level.lmg[3] = "m240";
	level.lmg[4] = "aug";
	level.assault = [];
	level.assault[0] = "ak47";
	level.assault[1] = "m16";
	level.assault[2] = "m4";
	level.assault[3] = "fn2000";
	level.assault[4] = "masada";
	level.assault[5] = "famas";
	level.assault[6] = "fal";
	level.assault[7] = "scar";
	level.assault[8] = "tavor";
	level.smg = [];
	level.smg[0] = "mp5k";
	level.smg[1] = "uzi";
	level.smg[2] = "p90";
	level.smg[3] = "kriss";
	level.smg[4] = "ump45";
	level.shot = [];
	level.shot[0] = "ranger";
	level.shot[1] = "model1887";
	level.shot[2] = "striker";
	level.shot[3] = "aa12";
	level.shot[4] = "m1014";
	level.shot[5] = "spas12";
	level.machine = [];
	level.machine[0] = "pp2000";
	level.machine[1] = "tmp";
	level.machine[2] = "glock";
	level.machine[3] = "beretta393";
	level.hand = [];
	level.hand[0] = "beretta";
	level.hand[1] = "usp";
	level.hand[2] = "deserteagle";
	level.hand[3] = "coltanaconda";
}

MenuInit()
{
	//First Dimension = Menu
	//Second Dimension = Option
	/****** Template ******//*
	level.humanM[i] = [];
	level.humanM[i][0] = "";
	level.humanM[i][1] = "";
	level.humanM[i][2] = "";
	i++;
	level.zombieM[i] = [];
	level.zombieM[i][0] = "";
	level.zombieM[i][1] = "";
	level.zombieM[i][2] = "";
	i++;*/
	/**********************/
	level.humanM = [];
	level.zombieM = [];
	
	/** Human Menu **/
	i = 0;
	
	level.humanM[i] = [];
	level.humanM[i][0] = "Buy Ammo for Current Weapon - " + level.itemCost["ammo"];
	level.humanM[i][1] = [];
	level.humanM[i][1]["LMG"] = "Press [{+actionslot 4}] - Exchange for a LMG - " + level.itemCost["LMG"];
	level.humanM[i][1]["Assault Rifle"] = "Press [{+actionslot 4}] - Exchange for an Assault Rifle - " + level.itemCost["Assault Rifle"];
	level.humanM[i][1]["Machine Pistol"] = "Press [{+actionslot 4}] - Exchange for a Machine Pistol - " + level.itemCost["Machine Pistol"];
	level.humanM[i][1]["Unavailable"] = "Weapon can not be Exchanged";
	level.humanM[i][2] = "Buy Riot Shield - " + level.itemCost["Riot"];
	i++;
	
	level.humanM[i] = [];
	level.humanM[i][0] = "Upgrade to Akimbo - " + level.itemCost["Akimbo"];
	level.humanM[i][1] = "Upgrade to FMJ - " + level.itemCost["FMJ"];
	level.humanM[i][2] = "Upgrade to Holographic - " + level.itemCost["Eotech"];
	i++;
	
	level.humanM[i] = [];
	level.humanM[i][0] = "Upgrade to Silencer - " + level.itemCost["Silencer"];
	level.humanM[i][1] = "Upgrade to Extended Mags - " + level.itemCost["XMags"];
	level.humanM[i][2] = "Upgrade to Rapid Fire - " + level.itemCost["ROF"];
	i++;
	
	level.humanM[i] = [];
	level.humanM[i][0]["normal"] = "Buy Steady Aim - " + level.itemCost["SteadyAim"];
	level.humanM[i][0]["pro"] = "Upgrade to Steady Aim Pro - " + level.itemCost["SteadyAimPro"];
	level.humanM[i][1]["normal"] = "Buy Sleight of Hand - " + level.itemCost["SleightOfHand"];
	level.humanM[i][1]["pro"] = "Upgrade to Sleight of Hand Pro - " + level.itemCost["SleightOfHandPro"];
	level.humanM[i][2]["normal"] = "Buy Sitrep - " + level.itemCost["SitRep"];
	level.humanM[i][2]["pro"] = "Upgrade to Sitrep Pro - " + level.itemCost["SitRepPro"];
	i++;
	
	level.humanM[i] = [];
	level.humanM[i][0]["normal"] = "Buy Stopping Power - " + level.itemCost["StoppingPower"];
	level.humanM[i][0]["pro"] = "Upgrade to Stopping Power Pro - " + level.itemCost["StoppingPowerPro"];
	level.humanM[i][1]["normal"] = "Buy Cold Blooded - " + level.itemCost["ColdBlooded"];
	level.humanM[i][1]["pro"] = "Upgrade to Cold Blooded Pro - " + level.itemCost["ColdBloodedPro"];
	level.humanM[i][2] = "Buy Sentry Gun - " + level.itemCost["SentryGun"];
	i++;
	
	/** Zombie Menu **/
	i = 0;
	
	level.zombieM[i] = [];
	level.zombieM[i][0] = "Buy Health - " + level.itemCost["health"];
	level.zombieM[i][1] = "Buy Thermal Overlay - " + level.itemCost["Thermal"];
	level.zombieM[i][2] = "Buy Throwing Knife - " + level.itemCost["ThrowingKnife"];
	i++;
	
	level.zombieM[i] = [];
	level.zombieM[i][0]["normal"] = "Buy Cold Blooded - " + level.itemCost["ColdBlooded"];
	level.zombieM[i][0]["pro"] = "Upgrade to Cold Blooded Pro - " + level.itemCost["ColdBloodedPro"];
	level.zombieM[i][1]["normal"] = "Buy Ninja - " + level.itemCost["Ninja"];
	level.zombieM[i][1]["pro"] = "Upgrade to Ninja Pro -" + level.itemCost["NinjaPro"];
	level.zombieM[i][2]["normal"] = "Buy Lightweight - " + level.itemCost["Lightweight"];
	level.zombieM[i][2]["pro"] = "Upgrade to Lightweight Pro - " + level.itemCost["LightweightPro"];
	i++;
	
	level.zombieM[i] = [];
	level.zombieM[i][0]["normal"] = "Buy Final Stand - " + level.itemCost["FinalStand"];
	level.zombieM[i][1] = "";
	level.zombieM[i][2] = "";
	i++;
}

MapVoteInit()
{
	level.mapvote = [];
	level.mapvote[0] = "mp_afghan";
	level.mapvote[1] = "mp_boneyard";
	level.mapvote[2] = "mp_brecourt";
	level.mapvote[3] = "mp_checkpoint";
	level.mapvote[4] = "mp_derail";
	level.mapvote[5] = "mp_estate";
	level.mapvote[6] = "mp_favela";
	level.mapvote[7] = "mp_highrise";
	level.mapvote[8] = "mp_nightshift";
	level.mapvote[9] = "mp_invasion";
	level.mapvote[10] = "mp_quarry";
	level.mapvote[11] = "mp_rundown";
	level.mapvote[12] = "mp_rust";
	level.mapvote[13] = "mp_subbase";
	level.mapvote[14] = "mp_terminal";
	level.mapvote[15] = "mp_underpass";
	level.mapname = [];
	level.mapname[0] = "Afghan";
	level.mapname[1] = "Scrapyard";
	level.mapname[2] = "Wasteland";
	level.mapname[3] = "Karachi";
	level.mapname[4] = "Derail";
	level.mapname[5] = "Estate";
	level.mapname[6] = "Favela";
	level.mapname[7] = "Highrise";
	level.mapname[8] = "Skidrow";
	level.mapname[9] = "Invasion";
	level.mapname[10] = "Quarry";
	level.mapname[11] = "Rundown";
	level.mapname[12] = "Rust";
	level.mapname[13] = "Subbase";
	level.mapname[14] = "Terminal";
	level.mapname[15] = "Underpass";
}

createFog()
{
	level.mapCenter = maps\mp\gametypes\_spawnlogic::findBoxCenter( level.spawnMins, level.spawnMaxs );
	level._effect[ "FOW" ] = loadfx( "dust/nuke_aftermath_mp" );
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 0 , 0 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 0 , 3000 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 0 , -3000 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 3000 , 0 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 3000 , 3000 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( 3000 , -3000 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( -3000 , 0 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( -3000 , 3000 , 500 ));
	PlayFX(level._effect[ "FOW" ], level.mapCenter + ( -3000 , -3000 , 500 ));
}

OverRider() /** Overrides Everything **/
{
	for(;;)
	{
		level notify("abort_forfeit");
		level.prematchPeriod = 0;
		level.killcam = 0;
		level.killstreakRewards = 0;
		wait 1;
	}
}

ffend()
{
	level endon ( "game_ended" );
	for(i = 10; i > 0; i--)
	{
		foreach(player in level.players)
		{
			player iPrintlnBold("^1ERROR: Friendly Fires is Enabled. Game Ending");
		}
		wait .5;
	}
	exitLevel( false );
}

headend()
{
	level endon ( "game_ended" );
	for(i = 10; i > 0; i--)
	{
		foreach(player in level.players)
		{
			player iPrintlnBold("^1ERROR: Headshots Only is Enabled. Game Ending");
		}
		wait .5;
	}
	exitLevel( false );
}

destroyOnDeath()
{
	self waittill ( "death" );
	self.locatingText destroy();
	self.HintText destroy();
	self.healthtext destroy();
	self.cash destroy();
	self.option1 destroy();
	self.option2 destroy();
	self.option3 destroy();
	self.perkztext1 destroy();
	self.perkztext2 destroy();
	self.perkztext3 destroy();
	self.perkztext4 destroy();
	self.perkztext5 destroy();
}

OMAExploitFix()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		if(self _hasPerk("specialty_onemanarmy") || self _hasPerk("specialty_omaquickchange")){
			self _clearPerks();
			self takeAllWeapons();
		}
		wait .5;
	}
}

CashFix()
{
	self endon("disconnect");
	while(1)
	{
		if(self.bounty < 0){
			self.bounty = 0;
			self notify("CASH");
		}
		wait .5;
	}
}

RemoveTurrets()
{
	level deletePlacedEntity("misc_turret");
}

inizButtons()
{
	self.zbuttonAction = [];
	self.zbuttonAction[0]="+melee"; //E
	self.zbuttonAction[1]="weapnext"; // 1 or 2
	self.zbuttonAction[2]="+gostand"; // space
	self.zbuttonAction[3]="+actionslot 4"; // 4
	self.zbuttonAction[4]="+actionslot 1"; // N
	self.zbuttonAction[5]="+actionslot 2"; // 5
	self.zbuttonAction[6]="+actionslot 3"; // 3
	self.zbuttonAction[7]="+usereload"; // F
	self.zbuttonAction[8]="+frag"; // G
	self.zbuttonAction[9]="+smoke"; // Q
	self.zbuttonAction[10]="+forward"; // W
	self.zbuttonAction[11]="+back"; // S
	self.zbuttonAction[12]="+moveleft"; // A
	self.zbuttonAction[13]="+moveright"; // D
	self.zbuttonPressed = [];
	for(i=0; i<14; i++)
	{
		self.zbuttonPressed[self.buttonAction[i]] = 0;
		self thread monitorzButtons( self.buttonAction[i] );
	}
}

monitorzButtons( buttonIndex )
{
        self endon ( "disconnect" ); 
        self notifyOnPlayerCommand( buttonIndex, buttonIndex );
        for ( ;; )
        {
                self waittill( buttonIndex );
                self.zbuttonPressed[ buttonIndex ] = 1;
                wait .1;
                self.zbuttonPressed[ buttonIndex ] = 0;
        }
}

CreatePlayerHUD()
{
	self.HintText = self createFontString( "objective", 1.25 );
		self.HintText setPoint( "CENTER", "CENTER", 0, 50 );
		self.option1 = NewClientHudElem( self );
		self.option1.alignX = "center";
		self.option1.alignY = "bottom";
		self.option1.horzAlign = "center";
		self.option1.vertAlign = "bottom";
		self.option1.y = -60;
		self.option1.foreground = true;
		self.option1.fontScale = 1.35;
		self.option1.font = "objective";
		self.option1.alpha = 1;
		self.option1.glow = 1;
		self.option1.glowColor = ( 0, 0, 1 );
		self.option1.glowAlpha = 1;
		self.option1.color = ( 1.0, 1.0, 1.0 );
		self.option2 = NewClientHudElem( self );
		self.option2.alignX = "center";
		self.option2.alignY = "bottom";
		self.option2.horzAlign = "center";
		self.option2.vertAlign = "bottom";
		self.option2.y = -40;
		self.option2.foreground = true;
		self.option2.fontScale = 1.35;
		self.option2.font = "objective";
		self.option2.alpha = 1;
		self.option2.glow = 1;
		self.option2.glowColor = ( 0, 0, 1 );
		self.option2.glowAlpha = 1;
		self.option2.color = ( 1.0, 1.0, 1.0 );
		self.option3 = NewClientHudElem( self );
		self.option3.alignX = "center";
		self.option3.alignY = "bottom";
		self.option3.horzAlign = "center";
		self.option3.vertAlign = "bottom";
		self.option3.y = -20;
		self.option3.foreground = true;
		self.option3.fontScale = 1.35;
		self.option3.font = "objective";
		self.option3.alpha = 1;
		self.option3.glow = 1;
		self.option3.glowColor = ( 0, 0, 1 );
		self.option3.glowAlpha = 1;
		self.option3.color = ( 1.0, 1.0, 1.0 );
		self.perkztext1 = NewClientHudElem( self );
		self.perkztext1.alignX = "left";
		self.perkztext1.alignY = "top";
		self.perkztext1.horzAlign = "right";
		self.perkztext1.vertAlign = "top";
		self.perkztext1.x = -200;
		self.perkztext1.y = 25;
		self.perkztext1.foreground = true;
		self.perkztext1.fontScale = .6;
		self.perkztext1.font = "hudbig";
		self.perkztext1.alpha = 1;
		self.perkztext1.glow = 1;
		self.perkztext1.glowColor = ( 1, 0, 0 );
		self.perkztext1.glowAlpha = 1;
		self.perkztext1.color = ( 1.0, 1.0, 1.0 );
		self.perkztext2 = NewClientHudElem( self );
		self.perkztext2.alignX = "left";
		self.perkztext2.alignY = "top";
		self.perkztext2.horzAlign = "right";
		self.perkztext2.vertAlign = "top";
		self.perkztext2.x = -200;
		self.perkztext2.y = 50;
		self.perkztext2.foreground = true;
		self.perkztext2.fontScale = .6;
		self.perkztext2.font = "hudbig";
		self.perkztext2.alpha = 1;
		self.perkztext2.glow = 1;
		self.perkztext2.glowColor = ( 1, 0, 0 );
		self.perkztext2.glowAlpha = 1;
		self.perkztext2.color = ( 1.0, 1.0, 1.0 );
		self.perkztext3 = NewClientHudElem( self );
		self.perkztext3.alignX = "left";
		self.perkztext3.alignY = "top";
		self.perkztext3.horzAlign = "right";
		self.perkztext3.vertAlign = "top";
		self.perkztext3.x = -200;
		self.perkztext3.y = 75;
		self.perkztext3.foreground = true;
		self.perkztext3.fontScale = .6;
		self.perkztext3.font = "hudbig";
		self.perkztext3.alpha = 1;
		self.perkztext3.glow = 1;
		self.perkztext3.glowColor = ( 1, 0, 0 );
		self.perkztext3.glowAlpha = 1;
		self.perkztext3.color = ( 1.0, 1.0, 1.0 );
		self.perkztext4 = NewClientHudElem( self );
		self.perkztext4.alignX = "left";
		self.perkztext4.alignY = "top";
		self.perkztext4.horzAlign = "right";
		self.perkztext4.vertAlign = "top";
		self.perkztext4.x = -200;
		self.perkztext4.y = 100;
		self.perkztext4.foreground = true;
		self.perkztext4.fontScale = .6;
		self.perkztext4.font = "hudbig";
		self.perkztext4.alpha = 1;
		self.perkztext4.glow = 1;
		self.perkztext4.glowColor = ( 1, 0, 0 );
		self.perkztext4.glowAlpha = 1;
		self.perkztext4.color = ( 1.0, 1.0, 1.0 );
		self.perkztext5 = NewClientHudElem( self );
		self.perkztext5.alignX = "left";
		self.perkztext5.alignY = "top";
		self.perkztext5.horzAlign = "right";
		self.perkztext5.vertAlign = "top";
		self.perkztext5.x = -200;
		self.perkztext5.y = 125;
		self.perkztext5.foreground = true;
		self.perkztext5.fontScale = .6;
		self.perkztext5.font = "hudbig";
		self.perkztext5.alpha = 1;
		self.perkztext5.glow = 1;
		self.perkztext5.glowColor = ( 1, 0, 0 );
		self.perkztext5.glowAlpha = 1;
		self.perkztext5.color = ( 1.0, 1.0, 1.0 );
}

CreateServerHUD()
{
	level.scrollleft = NewHudElem();
	level.scrollleft.alignX = "center";
	level.scrollleft.alignY = "bottom";
	level.scrollleft.horzAlign = "center";
	level.scrollleft.vertAlign = "bottom";
	level.scrollleft.x = -250;
	level.scrollleft.y = -30;
	level.scrollleft.foreground = true;
	level.scrollleft.fontScale = 2;
	level.scrollleft.font = "hudbig";
	level.scrollleft.alpha = 1;
	level.scrollleft.glow = 1;
	level.scrollleft.glowColor = ( 0, 0, 1 );
	level.scrollleft.glowAlpha = 1;
	level.scrollleft.color = ( 1.0, 1.0, 1.0 );
	level.scrollright = NewHudElem();
	level.scrollright.alignX = "center";
	level.scrollright.alignY = "bottom";
	level.scrollright.horzAlign = "center";
	level.scrollright.vertAlign = "bottom";
	level.scrollright.x = 250;
	level.scrollright.y = -30;
	level.scrollright.foreground = true;
	level.scrollright.fontScale = 2;
	level.scrollright.font = "hudbig";
	level.scrollright.alpha = 1;
	level.scrollright.glow = 1;
	level.scrollright.glowColor = ( 0, 0, 1 );
	level.scrollright.glowAlpha = 1;
	level.scrollright.color = ( 1.0, 1.0, 1.0 );
	level.infotext = NewHudElem();
	level.infotext.alignX = "center";
	level.infotext.alignY = "bottom";
	level.infotext.horzAlign = "center";
	level.infotext.vertAlign = "bottom";
	level.infotext.y = 25;
	level.infotext.foreground = true;
	level.infotext.fontScale = 1.35;
	level.infotext.font = "objective";
	level.infotext.alpha = 1;
	level.infotext.glow = 0;
	level.infotext.glowColor = ( 0, 0, 0 );
	level.infotext.glowAlpha = 1;
	level.infotext.color = ( 1.0, 1.0, 1.0 );
	level.infotext2 = NewHudElem();
	level.infotext2.alignX = "center";
	level.infotext2.alignY = "bottom";
	level.infotext2.horzAlign = "center";
	level.infotext2.vertAlign = "bottom";
	level.infotext2.y = 25;
	level.infotext2.foreground = true;
	level.infotext2.fontScale = 1.35;
	level.infotext2.font = "objective";
	level.infotext2.alpha = 1;
	level.infotext2.glow = 0;
	level.infotext2.glowColor = ( 0, 0, 0 );
	level.infotext2.glowAlpha = 1;
	level.infotext2.color = ( 1.0, 1.0, 1.0 );
	level.bar = level createServerBar((0.5, 0.5, 0.5), 1000, 25);
	level.bar.alignX = "center";
	level.bar.alignY = "bottom";
	level.bar.horzAlign = "center";
	level.bar.vertAlign = "bottom";
	level.bar.y = 30;
	level.bar.foreground = true;
	level thread doInfoScroll();
}

doSetup() /** Humans **/ 
{
	if(self.team == "axis" || self.team == "spectator"){
		self notify("menuresponse", game["menu_team"], "allies");
		wait .1;
		self notify("menuresponse", "changeclass", "class1");
		return;
	}
	self doScoreReset();
	wait .1;
	self notify("menuresponse", "changeclass", "class1");
	self takeAllWeapons();
	self _clearPerks();
	self ThermalVisionFOFOverlayOff();
	
	/** Weapons **/
	self.randomlmg = randomInt(5);
	self.randomar = randomInt(9);
	self.randommp = randomInt(4);
	self.randomsmg = randomInt(5);
	self.randomshot = randomInt(6);
	self.randomhand = randomInt(4);
	self giveWeapon(level.smg[self.randomsmg] + "_mp", 0, false);
	self giveWeapon(level.shot[self.randomshot] + "_mp", 0, false);
	self giveWeapon(level.hand[self.randomhand] + "_mp", 0, false);
	self GiveMaxAmmo(level.smg[self.randomsmg] + "_mp");
	self GiveMaxAmmo(level.shot[self.randomshot] + "_mp");
	self GiveMaxAmmo(level.hand[self.randomhand] + "_mp");
	self switchToWeapon(level.smg[self.randomsmg] + "_mp");
	self maps\mp\perks\_perks::givePerk("specialty_marathon");
	self maps\mp\perks\_perks::givePerk("specialty_automantle");
	self maps\mp\perks\_perks::givePerk("specialty_fastmantle");
	self maps\mp\perks\_perks::givePerk("specialty_heartbreaker");
	self maps\mp\perks\_perks::givePerk("specialty_quieter");
	self thread doHW();
	self.isZombie = 0;
	self.bounty = 0;
	self notify("CASH");
	self.attach1 = [];
	self.attachweapon = [];
	self.attachweapon[0] = 0;
	self.attachweapon[1] = 0;
	self.attachweapon[2] = 0;
	self.attach1[0] = "none";//SMG / Assault / LMG
	self.attach1[1] = "none";//Shotgun
	self.attach1[2] = "none";//Handgun / Machine Pistol
	self.currentweapon = 0;
	self thread doPerksSetup();
	self thread doPerkCheck();
	
	/** Stats **/
	self.maxhp = 100;
	self.maxhealth = self.maxhp;
	self.health = self.maxhealth;
	self notify("health");
	self.moveSpeedScaler = 1;
	self.thermal = 0;
	self.throwingknife = 0;
	self setClientDvar("g_knockback", 1000);
	
	self thread maps\mp\gametypes\_hud_message::resetNotify();
	notifySpawn = spawnstruct();
	notifySpawn.titleText = "Human";
	notifySpawn.notifyText = "Survive for as long as possible!";
	notifySpawn.glowColor = (0.0, 0.0, 1.0);
	self thread maps\mp\gametypes\_hud_message::notifyMessage( notifySpawn );
	self thread doHumanBounty();
	self thread doHumanShop();
}

doLastAlive() /** Last Human **/
{
	self endon("disconnect");
	self endon("death");
	wait 60;
	self thread maps\mp\gametypes\_hud_message::hintMessage("^1The Zombies Got Your Scent. ColdBlooded is off!");
	for(;;)
	{
		self _unsetPerk("specialty_coldblooded");
		self _unsetPerk("specialty_spygame");
		self.perkz["coldblooded"] = 3;
		wait .4;
	}
}

doAlphaZombie() /** Alpha Zombies **/ 
{
	if(self.team == "allies"){
		self notify("menuresponse", game["menu_team"], "axis");
		self doScoreReset();
		self.bounty = 0;
		self notify("CASH");
		self.ck = self.kills;
		self.cd = self.deaths;
		self.cs = self.suicides;
		self.maxhp = 200;
		self thread doPerksSetup();
		wait .1;
		self notify("menuresponse", "changeclass", "class3");
		return;
	}
	wait .1;
	self notify("menuresponse", "changeclass", "class3");
	self takeAllWeapons();
	self _clearPerks();
	
	/** Weapon **/
	self giveWeapon("usp_tactical_mp", 0, false);
	self thread doZW();
	self maps\mp\perks\_perks::givePerk("specialty_marathon");
	self maps\mp\perks\_perks::givePerk("specialty_automantle");
	self maps\mp\perks\_perks::givePerk("specialty_fastmantle");
	self maps\mp\perks\_perks::givePerk("specialty_extendedmelee");
	self maps\mp\perks\_perks::givePerk("specialty_falldamage");
	self maps\mp\perks\_perks::givePerk("specialty_thermal");
	if(self.thermal == 1){
		self ThermalVisionFOFOverlayOn();
	}
	if(self.throwingknife == 1){
		self thread monitorThrowingKnife();
		self maps\mp\perks\_perks::givePerk( "throwingknife_mp" );
		self setWeaponAmmoClip("throwingknife_mp", 1);
	}
	self thread doPerkCheck();
	
	/** Stats **/
	self.maxhealth = self.maxhp;
	self.health = self.maxhealth;
	self notify("health");
	self.moveSpeedScaler = 1.25;
	self setClientDvar("g_knockback", 3500);
	
	self thread maps\mp\gametypes\_hud_message::resetNotify();
	notifySpawn = spawnstruct();
	notifySpawn.titleText = "^0Alpha Zombie";
	notifySpawn.notifyText = "Kill the Humans!";
	notifySpawn.glowColor = (1.0, 0.0, 0.0);
	self thread maps\mp\gametypes\_hud_message::notifyMessage( notifySpawn );
	self thread doZombieBounty();
	self thread doZombieShop();
}

doZombie() /** Zombies **/
{
	if(self.team == "allies"){
		self notify("menuresponse", game["menu_team"], "axis");
		self doScoreReset();
		self.bounty = 0;
		self notify("CASH");
		self.ck = self.kills;
		self.cd = self.deaths;
		self.cs = self.suicides;
		self.maxhp = 100;
		self thread doPerksSetup();
		wait .1;
		self notify("menuresponse", "changeclass", "class3");
		return;
	}
	wait .1;
	self notify("menuresponse", "changeclass", "class3");
	self takeAllWeapons();
	self _clearPerks();
	
	/** Weapon **/
	self giveWeapon("usp_tactical_mp", 0, false);
	self thread doZW();
	self maps\mp\perks\_perks::givePerk("specialty_marathon");
	self maps\mp\perks\_perks::givePerk("specialty_automantle");
	self maps\mp\perks\_perks::givePerk("specialty_fastmantle");
	self maps\mp\perks\_perks::givePerk("specialty_extendedmelee");
	self maps\mp\perks\_perks::givePerk("specialty_falldamage");
	self maps\mp\perks\_perks::givePerk("specialty_thermal");
	if(self.thermal == 1){
		self ThermalVisionFOFOverlayOn();
	}
	if(self.throwingknife == 1){
		self thread monitorThrowingKnife();
		self maps\mp\perks\_perks::givePerk( "throwingknife_mp" );
		self setWeaponAmmoClip("throwingknife_mp", 1);
	}
	self thread doPerkCheck();
	
	/** Stats **/
	self.maxhealth = self.maxhp;
	self.health = self.maxhealth;
	self notify("health");
	self.moveSpeedScaler = 1.15;
	self setClientDvar("g_knockback", 3500);
	
	self thread maps\mp\gametypes\_hud_message::resetNotify();
	notifySpawn = spawnstruct();
	notifySpawn.titleText = "^0Zombie";
	notifySpawn.notifyText = "Kill the Humans!";
	notifySpawn.glowColor = (1.0, 0.0, 0.0);
	self thread maps\mp\gametypes\_hud_message::notifyMessage( notifySpawn );
	self thread doZombieBounty();
	self thread doZombieShop();
}

doHW() /** Check Human Weapon **/
{
	self endon ( "disconnect" );
	self endon ( "death" );
	while(1)
	{
		self.current = self getCurrentWeapon();
		switch(getWeaponClass(self.current))
		{
			case "weapon_lmg":
				self.exTo = "Unavailable";
				self.currentweapon = 0;
				break;
			case "weapon_assault":
				self.exTo = "LMG";
				self.currentweapon = 0;
				break;
			case "weapon_smg":
				self.exTo = "Assault Rifle";
				self.currentweapon = 0;
				break;
			case "weapon_shotgun":
				self.exTo = "Unavailable";
				self.currentweapon = 1;
				break;
			case "weapon_machine_pistol":
				self.exTo = "Unavailable";
				self.currentweapon = 2;
				break;
			case "weapon_pistol":
				self.exTo = "Machine Pistol";
				self.currentweapon = 2;
				break;
			default:
				self.exTo = "Unavailable";
				self.currentweapon = 3;
				break;
		}
		basename = strtok(self.current, "_");
		if(basename.size > 2){
			self.attach1[self.currentweapon] = basename[1];
			self.attachweapon[self.currentweapon] = basename.size - 2;
		} else {
			self.attach1[self.currentweapon] = "none";
			self.attachweapon[self.currentweapon] = 0;
		}
		if(self.currentweapon == 3 || self.attachweapon[self.currentweapon] == 2){
			self.attach["akimbo"] = 0;
			self.attach["fmj"] = 0;
			self.attach["eotech"] = 0;
			self.attach["silencer"] = 0;
			self.attach["xmags"] = 0;
			self.attach["rof"] = 0;
		}
		if((self.attachweapon[self.currentweapon] == 0) || (self.attachweapon[self.currentweapon] == 1)){
			akimbo = buildWeaponName(basename[0], self.attach1[self.currentweapon], "akimbo");
			fmj = buildWeaponName(basename[0], self.attach1[self.currentweapon], "fmj");
			eotech = buildWeaponName(basename[0], self.attach1[self.currentweapon], "eotech");
			silencer = buildWeaponName(basename[0], self.attach1[self.currentweapon], "silencer");
			xmags = buildWeaponName(basename[0], self.attach1[self.currentweapon], "xmags");
			rof = buildWeaponName(basename[0], self.attach1[self.currentweapon], "rof");
			if(isValidWeapon(akimbo)){
				self.attach["akimbo"] = 1;
			} else {
				self.attach["akimbo"] = 0;
			}
			if(isValidWeapon(fmj)){
				self.attach["fmj"] = 1;
			} else {
				self.attach["fmj"] = 0;
			}
			if(isValidWeapon(eotech)){
				self.attach["eotech"] = 1;
			} else {
				self.attach["eotech"] = 0;
			}
			if(isValidWeapon(silencer)){
				self.attach["silencer"] = 1;
			} else {
				self.attach["silencer"] = 0;
			}
			if(isValidWeapon(xmags)){
				self.attach["xmags"] = 1;
			} else {
				self.attach["xmags"] = 0;
			}
			if(isValidWeapon(rof)){
				self.attach["rof"] = 1;
			} else {
				self.attach["rof"] = 0;
			}
		}
		wait .5;
	}
}

doZW() /** Makes sure Zombies can't switch weapons **/
{
	self endon ( "disconnect" );
	self endon ( "death" );
	while(1)
	{
		if(self getCurrentWeapon() == "usp_tactical_mp"){
			self setWeaponAmmoClip("usp_tactical_mp", 0);
			self setWeaponAmmoStock("usp_tactical_mp", 0);
		} else {
			current = self getCurrentWeapon();
			self takeWeapon(current);
			self switchToWeapon("usp_tactical_mp");
		}
		wait .5;
	}
}

doPerkCheck()
{
	self endon ( "disconnect" );
	self endon ( "death" );
	while(1)
	{
		if(self.perkz["steadyaim"] == 1){
			if(!self _hasPerk("specialty_bulletaccuracy")){
				self maps\mp\perks\_perks::givePerk("specialty_bulletaccuracy");
			}
		}
		if(self.perkz["steadyaim"] == 2){
			if(!self _hasPerk("specialty_bulletaccuracy")){
				self maps\mp\perks\_perks::givePerk("specialty_bulletaccuracy");
			}
			if(!self _hasPerk("specialty_holdbreath")){
				self maps\mp\perks\_perks::givePerk("specialty_holdbreath");
			}
		}
		if(self.perkz["sleightofhand"] == 1){
			if(!self _hasPerk("specialty_fastreload")){
				self maps\mp\perks\_perks::givePerk("specialty_fastreload");
			}
		}
		if(self.perkz["sleightofhand"] == 2){
			if(!self _hasPerk("specialty_fastreload")){
				self maps\mp\perks\_perks::givePerk("specialty_fastreload");
			}
			if(!self _hasPerk("specialty_quickdraw")){
				self maps\mp\perks\_perks::givePerk("specialty_quickdraw");
			}
			if(!self _hasPerk("specialty_fastsnipe")){
				self maps\mp\perks\_perks::givePerk("specialty_fastsnipe");
			}
		}
		if(self.perkz["sitrep"] == 1){
			if(!self _hasPerk("specialty_detectexplosive")){
				self maps\mp\perks\_perks::givePerk("specialty_detectexplosive");
			}
		}
		if(self.perkz["sitrep"] == 2){
			if(!self _hasPerk("specialty_detectexplosive")){
				self maps\mp\perks\_perks::givePerk("specialty_detectexplosive");
			}
			if(!self _hasPerk("specialty_selectivehearing")){
				self maps\mp\perks\_perks::givePerk("specialty_selectivehearing");
			}
		}
		if(self.perkz["stoppingpower"] == 1){
			if(!self _hasPerk("specialty_bulletdamage")){
				self maps\mp\perks\_perks::givePerk("specialty_bulletdamage");
			}
		}
		if(self.perkz["stoppingpower"] == 2){
			if(!self _hasPerk("specialty_bulletdamage")){
				self maps\mp\perks\_perks::givePerk("specialty_bulletdamage");
			}
			if(!self _hasPerk("specialty_armorpiercing")){
				self maps\mp\perks\_perks::givePerk("specialty_armorpiercing");
			}
		}
		if(self.perkz["coldblooded"] == 1){
			if(!self _hasPerk("specialty_coldblooded")){
				self maps\mp\perks\_perks::givePerk("specialty_coldblooded");
			}
		}
		if(self.perkz["coldblooded"] == 2){
			if(!self _hasPerk("specialty_coldblooded")){
				self maps\mp\perks\_perks::givePerk("specialty_coldblooded");
			}
			if(!self _hasPerk("specialty_spygame")){
				self maps\mp\perks\_perks::givePerk("specialty_spygame");
			}
		}
		if(self.perkz["ninja"] == 1){
			if(!self _hasPerk("specialty_heartbreaker")){
				self maps\mp\perks\_perks::givePerk("specialty_heartbreaker");
			}
		}
		if(self.perkz["ninja"] == 2){
			if(!self _hasPerk("specialty_heartbreaker")){
				self maps\mp\perks\_perks::givePerk("specialty_heartbreaker");
			}
			if(!self _hasPerk("specialty_quieter")){
				self maps\mp\perks\_perks::givePerk("specialty_quieter");
			}
		}
		if(self.perkz["lightweight"] == 1){
			if(!self _hasPerk("specialty_lightweight")){
				self maps\mp\perks\_perks::givePerk("specialty_lightweight");
			}
			self setMoveSpeedScale(1.2);
		}
		if(self.perkz["lightweight"] == 2){
			if(!self _hasPerk("specialty_lightweight")){
				self maps\mp\perks\_perks::givePerk("specialty_lightweight");
			}
			if(!self _hasPerk("specialty_fastsprintrecovery")){
				self maps\mp\perks\_perks::givePerk("specialty_fastsprintrecovery");
			}
			self setMoveSpeedScale(1.5);
		}
		if(self.perkz["finalstand"] == 2){
			if(!self _hasPerk("specialty_finalstand")){
				self maps\mp\perks\_perks::givePerk("specialty_finalstand");
			}
		}
		wait 1;
	}
}

monitorThrowingKnife()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		if(self.buttonPressed[ "+frag" ] == 1){
			self.buttonPressed[ "+frag" ] = 0;
			self.throwingknife = 0;
		}
		wait .04;
	}
}

doHumanBounty()
{
	self endon("disconnect");
	self endon("death");
	self.ck = self.kills;
	self.ca = self.assists;
	for(;;)
	{
		if(self.kills - self.ck > 0){
			self.bounty += 50;
			self.ck++;
			self notify("CASH");
		}
		if(self.assists - self.ca > 0){
			self.bounty += 25;
			self.ca++;
			self notify("CASH");
		}
		wait .5;
	}
}

doZombieBounty()
{
	self endon("disconnect");
	self endon("death");
	for(;;)
	{
		if(self.kills - self.ck > 0){
			self.bounty += 100;
			self.ck++;
			self notify("CASH");
		}
		if(self.deaths - self.cd > 0){
			self.bounty += 50;
			self.cd++;
			self notify("CASH");
		}
		if(self.suicides - self.cs > 0){
			self.bounty -= 50;
			self.cs++;
			self notify("CASH");
		}
		wait .5;
	}
}

doHumanShop()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		if(self.buttonPressed[ "+actionslot 3" ] == 1){
			self.buttonPressed[ "+actionslot 3" ] = 0;
			if(self.menu == 0){
				if(self.bounty >= level.itemCost["ammo"]){
					self.bounty -= level.itemCost["ammo"];
					self GiveMaxAmmo(self.current);
					self notify("CASH");
				} else {
					self iPrintlnBold("^1Not Enough ^3Cash");
				}
			}
			if(self.menu == 1){
				if(self.attach["akimbo"] == 1){
					if(self.bounty >= level.itemCost["Akimbo"]){
						self.bounty -= level.itemCost["Akimbo"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "akimbo");
						self takeWeapon(self.current);
						self giveWeapon(gun , 0, true);
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 2){
				if(self.attach["silencer"] == 1){
					if(self.bounty >= level.itemCost["Silencer"]){
						self.bounty -= level.itemCost["Silencer"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "silencer");
						self takeWeapon(self.current);
						if(self.attach1[self.currentweapon] == "akimbo"){
							self giveWeapon(gun , 0, true);
						} else {
							self giveWeapon(gun , 0, false);
						}
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 3){
				switch(self.perkz["steadyaim"])
				{
					case 0:
						if(self.bounty >= level.itemCost["SteadyAim"]){
							self.bounty -= level.itemCost["SteadyAim"];
							self.perkz["steadyaim"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["SteadyAimPro"]){
							self.bounty -= level.itemCost["SteadyAimPro"];
							self.perkz["steadyaim"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			if(self.menu == 4){
				switch(self.perkz["stoppingpower"])
				{
					case 0:
						if(self.bounty >= level.itemCost["StoppingPower"]){
							self.bounty -= level.itemCost["StoppingPower"];
							self.perkz["stoppingpower"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["StoppingPowerPro"]){
							self.bounty -= level.itemCost["StoppingPowerPro"];
							self.perkz["stoppingpower"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			wait .25;
		}
		if(self.buttonPressed[ "+actionslot 4" ] == 1){
			self.buttonPressed[ "+actionslot 4" ] = 0;
			if(self.menu == 0){
				self thread doExchangeWeapons();
			}
			if(self.menu == 1){
				if(self.attach["fmj"] == 1){
					if(self.bounty >= level.itemCost["FMJ"]){
						self.bounty -= level.itemCost["FMJ"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "fmj");
						self takeWeapon(self.current);
						if(self.attach1[self.currentweapon] == "akimbo"){
							self giveWeapon(gun , 0, true);
						} else {
							self giveWeapon(gun , 0, false);
						}
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 2){
				if(self.attach["xmags"] == 1){
					if(self.bounty >= level.itemCost["XMags"]){
						self.bounty -= level.itemCost["XMags"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "xmags");
						self takeWeapon(self.current);
						if(self.attach1[self.currentweapon] == "akimbo"){
							self giveWeapon(gun , 0, true);
						} else {
							self giveWeapon(gun , 0, false);
						}
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 3){
				switch(self.perkz["sleightofhand"])
				{
					case 0:
						if(self.bounty >= level.itemCost["SleightOfHand"]){
							self.bounty -= level.itemCost["SleightOfHand"];
							self.perkz["sleightofhand"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["SleightOfHandPro"]){
							self.bounty -= level.itemCost["SleightOfHandPro"];
							self.perkz["sleightofhand"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			if(self.menu == 4){
				switch(self.perkz["coldblooded"])
				{
					case 0:
						if(self.bounty >= level.itemCost["ColdBlooded"]){
							self.bounty -= level.itemCost["ColdBlooded"];
							self.perkz["coldblooded"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["ColdBloodedPro"]){
							self.bounty -= level.itemCost["ColdBloodedPro"];
							self.perkz["coldblooded"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			wait .25;
		}
		if(self.buttonPressed[ "+actionslot 2" ] == 1){
			self.buttonPressed[ "+actionslot 2" ] = 0;
			if(self.menu == 0){
				if(self.bounty >= level.itemCost["Riot"]){
					self.bounty -= level.itemCost["Riot"];
					self giveWeapon("riotshield_mp", 0, false);
					self switchToWeapon("riotshield_mp");
					self thread maps\mp\gametypes\_hud_message::hintMessage("^2Riot Shield Bought!");
					self notify("CASH");
				} else {
					self iPrintlnBold("^1Not Enough ^3Cash");
				}
			}
			if(self.menu == 1){
				if(self.attach["eotech"] == 1){
					if(self.bounty >= level.itemCost["Eotech"]){
						self.bounty -= level.itemCost["Eotech"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "eotech");
						self takeWeapon(self.current);
						if(self.attach1[self.currentweapon] == "akimbo"){
							self giveWeapon(gun , 0, true);
						} else {
							self giveWeapon(gun , 0, false);
						}
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 2){
				if(self.attach["rof"] == 1){
					if(self.bounty >= level.itemCost["ROF"]){
						self.bounty -= level.itemCost["ROF"];
						ammo = self GetWeaponAmmoStock(self.current);
						basename = strtok(self.current, "_");
						gun = buildWeaponName(basename[0], self.attach1[self.currentweapon], "rof");
						self takeWeapon(self.current);
						if(self.attach1[self.currentweapon] == "akimbo"){
							self giveWeapon(gun , 0, true);
						} else {
							self giveWeapon(gun , 0, false);
						}
						self SetWeaponAmmoStock( gun, ammo );
						self switchToWeapon(gun);
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Weapon Upgraded!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				}
			}
			if(self.menu == 3){
				switch(self.perkz["sitrep"])
				{
					case 0:
						if(self.bounty >= level.itemCost["SitRep"]){
							self.bounty -= level.itemCost["SitRep"];
							self.perkz["sitrep"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["SitRepPro"]){
							self.bounty -= level.itemCost["SitRepPro"];
							self.perkz["sitrep"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			if(self.menu == 4){
				if(self.bounty >= level.itemCost["SentryGun"]){
					self.bounty -= level.itemCost["SentryGun"];
					self notify("CASH");
					self thread maps\mp\gametypes\_hud_message::hintMessage("^2Sentry Gun Bought!");
					self maps\mp\killstreaks\_autosentry::giveSentry( "sentry_minigun" );
				} else {
					self iPrintlnBold("^1Not Enough ^3Cash");
				}
			}
			wait .25;
		}
		wait .04;
	}
}

doZombieShop()
{
	self endon("disconnect");
	self endon("death");
	while(1)
	{
		if(self.buttonPressed[ "+actionslot 3" ] == 1){
			self.buttonPressed[ "+actionslot 3" ] = 0;
			if(self.menu == 0){
				if(self.maxhp != 1000){
					if(self.bounty >= level.itemCost["health"]){
						self.bounty -= level.itemCost["health"];
						self.maxhp += level.itemCost["health"];
						self.maxhealth = self.maxhp;
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2 Health Increased!");
						self notify("CASH");
						self notify("health");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				} else {
					self thread maps\mp\gametypes\_hud_message::hintMessage("^1Max Health Achieved!");
				}
			}
			if(self.menu == 1){
				switch(self.perkz["coldblooded"])
				{
					case 0:
						if(self.bounty >= level.itemCost["ColdBlooded"]){
							self.bounty -= level.itemCost["ColdBlooded"];
							self.perkz["coldblooded"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["ColdBloodedPro"]){
							self.bounty -= level.itemCost["ColdBloodedPro"];
							self.perkz["coldblooded"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			if(self.menu == 2){
				switch(self.perkz["finalstand"])
				{
					case 0:
						if(self.bounty >= level.itemCost["FinalStand"]){
							self.bounty -= level.itemCost["FinalStand"];
							self.perkz["finalstand"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			wait .25;
		}
		if(self.buttonPressed[ "+actionslot 4" ] == 1){
			self.buttonPressed[ "+actionslot 4" ] = 0;
			if(self.menu == 0){
				if(self.thermal == 0){
					if(self.bounty >= level.itemCost["Thermal"]){
						self.bounty -= level.itemCost["Thermal"];
						self ThermalVisionFOFOverlayOn();
						self.thermal = 1;
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Thermal Vision Overlay Activated!");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				} else {
					self thread maps\mp\gametypes\_hud_message::hintMessage("^1Thermal already activated!");
				}
			}
			if(self.menu == 1){
				switch(self.perkz["ninja"])
				{
					case 0:
						if(self.bounty >= level.itemCost["Ninja"]){
							self.bounty -= level.itemCost["Ninja"];
							self.perkz["ninja"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["NinjaPro"]){
							self.bounty -= level.itemCost["NinjaPro"];
							self.perkz["ninja"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			wait .25;
		}
		if(self.buttonPressed[ "+actionslot 2" ] == 1){
			self.buttonPressed[ "+actionslot 2" ] = 0;
			if(self.menu == 0){
				if(self getWeaponAmmoClip("throwingknife_mp") == 0){
					if(self.bounty >= level.itemCost["ThrowingKnife"]){
						self.bounty -= level.itemCost["ThrowingKnife"];
						self thread monitorThrowingKnife();
						self maps\mp\perks\_perks::givePerk( "throwingknife_mp" );
						self setWeaponAmmoClip("throwingknife_mp", 1);
						self.throwingknife = 1;
						self thread maps\mp\gametypes\_hud_message::hintMessage("^2Throwing Knife Purchased");
						self notify("CASH");
					} else {
						self iPrintlnBold("^1Not Enough ^3Cash");
					}
				} else {
					self thread maps\mp\gametypes\_hud_message::hintMessage("^1Throwknife already on hand!");
				}
			}
			if(self.menu == 1){
				switch(self.perkz["lightweight"])
				{
					case 0:
						if(self.bounty >= level.itemCost["Lightweight"]){
							self.bounty -= level.itemCost["Lightweight"];
							self.perkz["lightweight"] = 1;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Bought!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					case 1:
						if(self.bounty >= level.itemCost["LightweightPro"]){
							self.bounty -= level.itemCost["LightweightPro"];
							self.perkz["lightweight"] = 2;
							self thread maps\mp\gametypes\_hud_message::hintMessage("^2Perk Upgraded!");
							self notify("CASH");
						} else {
							self iPrintlnBold("^1Not Enough ^3Cash");
						}
						break;
					default:
						break;
				}
			}
			wait .25;
		}
		wait .04;
	}
}

doExchangeWeapons()
{
	switch(self.exTo)
	{
		case "LMG":
			if(self.bounty >= level.itemCost["LMG"]){
				self.bounty -= level.itemCost["LMG"];
				self takeWeapon(self.current);
				self giveWeapon(level.lmg[self.randomlmg] + "_mp", 0, false);
				self GiveStartAmmo(level.lmg[self.randomlmg] + "_mp");
				self switchToWeapon(level.lmg[self.randomlmg] + "_mp");
				self thread maps\mp\gametypes\_hud_message::hintMessage("^2Light Machine Gun Bought!");
				self notify("CASH");
			} else {
				self iPrintlnBold("^1Not Enough ^3Cash");
			}
			break;
		case "Assault Rifle":
			if(self.bounty >= level.itemCost["Assault Rifle"]){
				self.bounty -= level.itemCost["Assault Rifle"];
				self takeWeapon(self.current);
				self giveWeapon(level.assault[self.randomar] + "_mp", 0, false);
				self GiveStartAmmo(level.assault[self.randomar] + "_mp");
				self switchToWeapon(level.assault[self.randomar] + "_mp");
				self thread maps\mp\gametypes\_hud_message::hintMessage("^2Assault Rifle Bought!");
				self notify("CASH");
			} else {
				self iPrintlnBold("^1Not Enough ^3Cash");
			}
			break;
		case "Machine Pistol":
			if(self.bounty >= level.itemCost["Machine Pistol"]){
				self.bounty -= level.itemCost["Machine Pistol"];
				self takeWeapon(self.current);
				self giveWeapon(level.machine[self.randommp] + "_mp", 0, false);
				self GiveStartAmmo(level.machine[self.randommp] + "_mp");
				self switchToWeapon(level.machine[self.randommp] + "_mp");
				self thread maps\mp\gametypes\_hud_message::hintMessage("^2Machine Pistol Bought!");
				self notify("CASH");
			} else {
				self iPrintlnBold("^1Not Enough ^3Cash");
			}
			break;
		default:
			break;
	}
}

buildWeaponName( baseName, attachment1, attachment2 )
{
	if ( !isDefined( level.letterToNumber ) )
		level.letterToNumber = makeLettersToNumbers();

	// disable bling when perks are disabled
	if ( getDvarInt ( "scr_game_perks" ) == 0 )
	{
		attachment2 = "none";

		if ( baseName == "onemanarmy" )
			return ( "beretta_mp" );
	}

	weaponName = baseName;
	attachments = [];

	if ( attachment1 != "none" && attachment2 != "none" )
	{
		if ( level.letterToNumber[attachment1[0]] < level.letterToNumber[attachment2[0]] )
		{
			
			attachments[0] = attachment1;
			attachments[1] = attachment2;
			
		}
		else if ( level.letterToNumber[attachment1[0]] == level.letterToNumber[attachment2[0]] )
		{
			if ( level.letterToNumber[attachment1[1]] < level.letterToNumber[attachment2[1]] )
			{
				attachments[0] = attachment1;
				attachments[1] = attachment2;
			}
			else
			{
				attachments[0] = attachment2;
				attachments[1] = attachment1;
			}	
		}
		else
		{
			attachments[0] = attachment2;
			attachments[1] = attachment1;
		}		
	}
	else if ( attachment1 != "none" )
	{
		attachments[0] = attachment1;
	}
	else if ( attachment2 != "none" )
	{
		attachments[0] = attachment2;	
	}
	
	foreach ( attachment in attachments )
	{
		weaponName += "_" + attachment;
	}

	return ( weaponName + "_mp" );
}

makeLettersToNumbers()
{
	array = [];
	
	array["a"] = 0;
	array["b"] = 1;
	array["c"] = 2;
	array["d"] = 3;
	array["e"] = 4;
	array["f"] = 5;
	array["g"] = 6;
	array["h"] = 7;
	array["i"] = 8;
	array["j"] = 9;
	array["k"] = 10;
	array["l"] = 11;
	array["m"] = 12;
	array["n"] = 13;
	array["o"] = 14;
	array["p"] = 15;
	array["q"] = 16;
	array["r"] = 17;
	array["s"] = 18;
	array["t"] = 19;
	array["u"] = 20;
	array["v"] = 21;
	array["w"] = 22;
	array["x"] = 23;
	array["y"] = 24;
	array["z"] = 25;
	
	return array;
}

isValidWeapon( refString )
{
	if ( !isDefined( level.weaponRefs ) )
	{
		level.weaponRefs = [];

		foreach ( weaponRef in level.weaponList )
			level.weaponRefs[ weaponRef ] = true;
	}

	if ( isDefined( level.weaponRefs[ refString ] ) )
		return true;

	assertMsg( "Replacing invalid weapon/attachment combo: " + refString );
	
	return false;
}